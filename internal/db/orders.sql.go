// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: orders.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (id, table_number, customer_name, customer_phone, customer_id, pax, basket_size, total_amount, order_status, created_by, payment_status)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'cooking', ?, 'unpaid')
RETURNING id
`

type CreateOrderParams struct {
	ID            string         `json:"id"`
	TableNumber   string         `json:"table_number"`
	CustomerName  sql.NullString `json:"customer_name"`
	CustomerPhone sql.NullString `json:"customer_phone"`
	CustomerID    sql.NullString `json:"customer_id"`
	Pax           int64          `json:"pax"`
	BasketSize    int64          `json:"basket_size"`
	TotalAmount   float64        `json:"total_amount"`
	CreatedBy     sql.NullString `json:"created_by"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createOrder,
		arg.ID,
		arg.TableNumber,
		arg.CustomerName,
		arg.CustomerPhone,
		arg.CustomerID,
		arg.Pax,
		arg.BasketSize,
		arg.TotalAmount,
		arg.CreatedBy,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (id, order_id, product_name, qty, price, destination, item_status)
VALUES (?, ?, ?, ?, ?, ?, 'pending')
RETURNING id, order_id, product_name, qty, price, destination, item_status, created_at, updated_at
`

type CreateOrderItemParams struct {
	ID          string  `json:"id"`
	OrderID     string  `json:"order_id"`
	ProductName string  `json:"product_name"`
	Qty         int64   `json:"qty"`
	Price       float64 `json:"price"`
	Destination string  `json:"destination"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRowContext(ctx, createOrderItem,
		arg.ID,
		arg.OrderID,
		arg.ProductName,
		arg.Qty,
		arg.Price,
		arg.Destination,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ProductName,
		&i.Qty,
		&i.Price,
		&i.Destination,
		&i.ItemStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (id, order_id, amount, payment_method, payment_note, created_by)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, order_id, amount, payment_method, payment_note, created_by, created_at
`

type CreatePaymentParams struct {
	ID            string         `json:"id"`
	OrderID       string         `json:"order_id"`
	Amount        float64        `json:"amount"`
	PaymentMethod string         `json:"payment_method"`
	PaymentNote   sql.NullString `json:"payment_note"`
	CreatedBy     string         `json:"created_by"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, createPayment,
		arg.ID,
		arg.OrderID,
		arg.Amount,
		arg.PaymentMethod,
		arg.PaymentNote,
		arg.CreatedBy,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.Amount,
		&i.PaymentMethod,
		&i.PaymentNote,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const createPrintJob = `-- name: CreatePrintJob :one
INSERT INTO print_queue (id, printer_id, data, status)
VALUES (?, ?, ?, 'pending')
RETURNING id, printer_id, data, status, retry_count, error_message, created_at, updated_at, locked_at, locked_by
`

type CreatePrintJobParams struct {
	ID        string `json:"id"`
	PrinterID string `json:"printer_id"`
	Data      string `json:"data"`
}

func (q *Queries) CreatePrintJob(ctx context.Context, arg CreatePrintJobParams) (PrintQueue, error) {
	row := q.db.QueryRowContext(ctx, createPrintJob, arg.ID, arg.PrinterID, arg.Data)
	var i PrintQueue
	err := row.Scan(
		&i.ID,
		&i.PrinterID,
		&i.Data,
		&i.Status,
		&i.RetryCount,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LockedAt,
		&i.LockedBy,
	)
	return i, err
}

const getMergedOrders = `-- name: GetMergedOrders :many
SELECT id, table_number, customer_name, customer_phone, customer_id, pax, basket_size, total_amount, paid_amount, order_status, payment_status, merged_from, is_merged, created_at, updated_at FROM orders
WHERE merged_from = ?
`

func (q *Queries) GetMergedOrders(ctx context.Context, mergedFrom sql.NullString) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getMergedOrders, mergedFrom)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TableNumber,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.CustomerID,
			&i.Pax,
			&i.BasketSize,
			&i.TotalAmount,
			&i.PaidAmount,
			&i.OrderStatus,
			&i.PaymentStatus,
			&i.MergedFrom,
			&i.IsMerged,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderAnalytics = `-- name: GetOrderAnalytics :one
SELECT 
    COUNT(*) as total_orders,
    SUM(total_amount) as total_revenue,
    AVG(total_amount) as avg_order_value,
    AVG(basket_size) as avg_basket_size,
    AVG(pax) as avg_pax,
    SUM(pax) as total_pax
FROM orders
WHERE created_at BETWEEN ? AND ?
AND payment_status = 'paid'
`

type GetOrderAnalyticsParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetOrderAnalyticsRow struct {
	TotalOrders   int64           `json:"total_orders"`
	TotalRevenue  sql.NullFloat64 `json:"total_revenue"`
	AvgOrderValue sql.NullFloat64 `json:"avg_order_value"`
	AvgBasketSize sql.NullFloat64 `json:"avg_basket_size"`
	AvgPax        sql.NullFloat64 `json:"avg_pax"`
	TotalPax      sql.NullFloat64 `json:"total_pax"`
}

func (q *Queries) GetOrderAnalytics(ctx context.Context, arg GetOrderAnalyticsParams) (GetOrderAnalyticsRow, error) {
	row := q.db.QueryRowContext(ctx, getOrderAnalytics, arg.CreatedAt, arg.CreatedAt_2)
	var i GetOrderAnalyticsRow
	err := row.Scan(
		&i.TotalOrders,
		&i.TotalRevenue,
		&i.AvgOrderValue,
		&i.AvgBasketSize,
		&i.AvgPax,
		&i.TotalPax,
	)
	return i, err
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT id, order_id, product_name, qty, price, destination, item_status, created_at, updated_at FROM order_items
WHERE order_id = ?
ORDER BY created_at
`

func (q *Queries) GetOrderItems(ctx context.Context, orderID string) ([]OrderItem, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderItem{}
	for rows.Next() {
		var i OrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductName,
			&i.Qty,
			&i.Price,
			&i.Destination,
			&i.ItemStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderTotalPaid = `-- name: GetOrderTotalPaid :one
SELECT COALESCE(SUM(amount), 0) as total_paid
FROM payments
WHERE order_id = ?
`

func (q *Queries) GetOrderTotalPaid(ctx context.Context, orderID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getOrderTotalPaid, orderID)
	var total_paid interface{}
	err := row.Scan(&total_paid)
	return total_paid, err
}

const getOrderWithItems = `-- name: GetOrderWithItems :one
SELECT id, table_number, customer_name, customer_phone, customer_id, pax, basket_size, total_amount, paid_amount, order_status, created_by, payment_status, merged_from, is_merged, created_at, updated_at FROM orders
WHERE id = ? LIMIT 1
`

func (q *Queries) GetOrderWithItems(ctx context.Context, id string) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderWithItems, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.TableNumber,
		&i.CustomerName,
		&i.CustomerPhone,
		&i.CustomerID,
		&i.Pax,
		&i.BasketSize,
		&i.TotalAmount,
		&i.PaidAmount,
		&i.OrderStatus,
		&i.CreatedBy,
		&i.PaymentStatus,
		&i.MergedFrom,
		&i.IsMerged,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrdersByTable = `-- name: GetOrdersByTable :many
SELECT id, table_number, customer_name, customer_phone, customer_id, pax, basket_size, total_amount, paid_amount, order_status, created_by, payment_status, merged_from, is_merged, created_at, updated_at FROM orders
WHERE table_number = ?
AND voided_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) GetOrdersByTable(ctx context.Context, tableNumber string) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getOrdersByTable, tableNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TableNumber,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.CustomerID,
			&i.Pax,
			&i.BasketSize,
			&i.TotalAmount,
			&i.PaidAmount,
			&i.OrderStatus,
			&i.CreatedBy,
			&i.PaymentStatus,
			&i.MergedFrom,
			&i.IsMerged,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentsByOrder = `-- name: GetPaymentsByOrder :many
SELECT id, order_id, amount, payment_method, payment_note, created_by, created_at FROM payments
WHERE order_id = ?
ORDER BY created_at
`

func (q *Queries) GetPaymentsByOrder(ctx context.Context, orderID string) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentsByOrder, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.Amount,
			&i.PaymentMethod,
			&i.PaymentNote,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingOrders = `-- name: GetPendingOrders :many
SELECT id, table_number, customer_name, customer_phone, customer_id, pax, basket_size, total_amount, paid_amount, order_status, created_by, payment_status, merged_from, is_merged, created_at, updated_at FROM orders
WHERE order_status IN ('cooking', 'ready')
AND voided_at IS NULL
ORDER BY created_at ASC
`

func (q *Queries) GetPendingOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, getPendingOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TableNumber,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.CustomerID,
			&i.Pax,
			&i.BasketSize,
			&i.TotalAmount,
			&i.PaidAmount,
			&i.OrderStatus,
			&i.CreatedBy,
			&i.PaymentStatus,
			&i.MergedFrom,
			&i.IsMerged,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingPrintJobs = `-- name: GetPendingPrintJobs :many
SELECT id, printer_id, data, status, retry_count, error_message, created_at, updated_at, locked_at, locked_by
FROM print_queue
WHERE status = 'pending'
ORDER BY created_at ASC, id ASC
`

func (q *Queries) GetPendingPrintJobs(ctx context.Context) ([]PrintQueue, error) {
	rows, err := q.db.QueryContext(ctx, getPendingPrintJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PrintQueue{}
	for rows.Next() {
		var i PrintQueue
		if err := rows.Scan(
			&i.ID,
			&i.PrinterID,
			&i.Data,
			&i.Status,
			&i.RetryCount,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LockedAt,
			&i.LockedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsSold = `-- name: GetProductsSold :one
SELECT 
    COALESCE(SUM(oi.qty), 0) as total_qty
FROM order_items oi
INNER JOIN orders o ON oi.order_id = o.id
WHERE o.created_at BETWEEN ? AND ?
`

type GetProductsSoldParams struct {
	FromCreatedAt   time.Time `json:"from_created_at"`
	FromCreatedAt_2 time.Time `json:"from_created_at_2"`
	ToCreatedAt     time.Time `json:"to_created_at"`
	ToCreatedAt_2   time.Time `json:"to_created_at_2"`
}

func (q *Queries) GetProductsSold(ctx context.Context, arg GetProductsSoldParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getProductsSold,
		arg.FromCreatedAt,
		arg.FromCreatedAt_2,
		arg.ToCreatedAt,
		arg.ToCreatedAt_2,
	)
	var total_qty interface{}
	err := row.Scan(&total_qty)
	return total_qty, err
}

const getRevenueByDay = `-- name: GetRevenueByDay :many
SELECT 
    DATE(created_at) as day,
    COALESCE(SUM(total_amount), 0) as revenue
FROM orders
WHERE created_at BETWEEN ? AND ?
GROUP BY DATE(created_at)
ORDER BY day
`

type GetRevenueByDayParams struct {
	FromCreatedAt time.Time `json:"from_created_at"`
	ToCreatedAt   time.Time `json:"to_created_at"`
}

type GetRevenueByDayRow struct {
	Day     interface{} `json:"day"`
	Revenue interface{} `json:"revenue"`
}

func (q *Queries) GetRevenueByDay(ctx context.Context, arg GetRevenueByDayParams) ([]GetRevenueByDayRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevenueByDay, arg.FromCreatedAt, arg.ToCreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRevenueByDayRow{}
	for rows.Next() {
		var i GetRevenueByDayRow
		if err := rows.Scan(&i.Day, &i.Revenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueByHour = `-- name: GetRevenueByHour :many
SELECT 
    strftime('%H', created_at) as hour,
    COALESCE(SUM(total_amount), 0) as revenue
FROM orders
WHERE DATE(created_at) = ?
GROUP BY strftime('%H', created_at)
ORDER BY hour
`

type GetRevenueByHourRow struct {
	Hour    interface{} `json:"hour"`
	Revenue interface{} `json:"revenue"`
}

func (q *Queries) GetRevenueByHour(ctx context.Context, createdAt time.Time) ([]GetRevenueByHourRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevenueByHour, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRevenueByHourRow{}
	for rows.Next() {
		var i GetRevenueByHourRow
		if err := rows.Scan(&i.Hour, &i.Revenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueByPaymentStatus = `-- name: GetRevenueByPaymentStatus :one
SELECT 
    COALESCE(SUM(CASE WHEN payment_status = 'paid' THEN total_amount ELSE 0 END), 0) as paid_revenue,
    COALESCE(SUM(CASE WHEN payment_status = 'unpaid' THEN total_amount ELSE 0 END), 0) as unpaid_revenue
FROM orders
WHERE created_at BETWEEN ? AND ?
`

type GetRevenueByPaymentStatusParams struct {
	FromCreatedAt time.Time `json:"from_created_at"`
	ToCreatedAt   time.Time `json:"to_created_at"`
}

type GetRevenueByPaymentStatusRow struct {
	PaidRevenue   interface{} `json:"paid_revenue"`
	UnpaidRevenue interface{} `json:"unpaid_revenue"`
}

func (q *Queries) GetRevenueByPaymentStatus(ctx context.Context, arg GetRevenueByPaymentStatusParams) (GetRevenueByPaymentStatusRow, error) {
	row := q.db.QueryRowContext(ctx, getRevenueByPaymentStatus, arg.FromCreatedAt, arg.ToCreatedAt)
	var i GetRevenueByPaymentStatusRow
	err := row.Scan(&i.PaidRevenue, &i.UnpaidRevenue)
	return i, err
}

const listOrdersByCustomer = `-- name: ListOrdersByCustomer :many
SELECT id, table_number, customer_name, customer_phone, customer_id, pax, basket_size, total_amount, paid_amount, order_status, created_by, payment_status, merged_from, is_merged, created_at, updated_at
FROM orders
WHERE customer_id = ?1
AND created_at BETWEEN ?2 AND ?3
ORDER BY created_at DESC
`

func (q *Queries) ListOrdersByCustomer(ctx context.Context, customerID sql.NullString) ([]Order, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByCustomer, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.TableNumber,
			&i.CustomerName,
			&i.CustomerPhone,
			&i.CustomerID,
			&i.Pax,
			&i.BasketSize,
			&i.TotalAmount,
			&i.PaidAmount,
			&i.OrderStatus,
			&i.CreatedBy,
			&i.PaymentStatus,
			&i.MergedFrom,
			&i.IsMerged,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeOrders = `-- name: MergeOrders :exec
UPDATE orders
SET is_merged = 1, merged_from = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type MergeOrdersParams struct {
	MergedFrom sql.NullString `json:"merged_from"`
	ID         string         `json:"id"`
}

func (q *Queries) MergeOrders(ctx context.Context, arg MergeOrdersParams) error {
	_, err := q.db.ExecContext(ctx, mergeOrders, arg.MergedFrom, arg.ID)
	return err
}

const transferOrderItems = `-- name: TransferOrderItems :exec
UPDATE order_items
SET order_id = ?, updated_at = CURRENT_TIMESTAMP
WHERE order_id = ?
`

type TransferOrderItemsParams struct {
	OrderID   string `json:"order_id"`
	OrderID_2 string `json:"order_id_2"`
}

func (q *Queries) TransferOrderItems(ctx context.Context, arg TransferOrderItemsParams) error {
	_, err := q.db.ExecContext(ctx, transferOrderItems, arg.OrderID, arg.OrderID_2)
	return err
}

const updateOrderItemStatus = `-- name: UpdateOrderItemStatus :exec
UPDATE order_items
SET item_status = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateOrderItemStatusParams struct {
	ItemStatus string `json:"item_status"`
	ID         string `json:"id"`
}

func (q *Queries) UpdateOrderItemStatus(ctx context.Context, arg UpdateOrderItemStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateOrderItemStatus, arg.ItemStatus, arg.ID)
	return err
}

const updateOrderPaidAmount = `-- name: UpdateOrderPaidAmount :exec
UPDATE orders
SET paid_amount = ?, payment_status = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateOrderPaidAmountParams struct {
	PaidAmount    float64 `json:"paid_amount"`
	PaymentStatus string  `json:"payment_status"`
	ID            string  `json:"id"`
}

func (q *Queries) UpdateOrderPaidAmount(ctx context.Context, arg UpdateOrderPaidAmountParams) error {
	_, err := q.db.ExecContext(ctx, updateOrderPaidAmount, arg.PaidAmount, arg.PaymentStatus, arg.ID)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders
SET order_status = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateOrderStatusParams struct {
	OrderStatus string `json:"order_status"`
	ID          string `json:"id"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateOrderStatus, arg.OrderStatus, arg.ID)
	return err
}

const updateOrderTotals = `-- name: UpdateOrderTotals :exec
UPDATE orders
SET total_amount = total_amount + ?, basket_size = basket_size + ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateOrderTotalsParams struct {
	TotalAmount float64 `json:"total_amount"`
	BasketSize  int64   `json:"basket_size"`
	ID          string  `json:"id"`
}

func (q *Queries) UpdateOrderTotals(ctx context.Context, arg UpdateOrderTotalsParams) error {
	_, err := q.db.ExecContext(ctx, updateOrderTotals, arg.TotalAmount, arg.BasketSize, arg.ID)
	return err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :exec
UPDATE orders
SET payment_status = 'paid', updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) UpdatePaymentStatus(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updatePaymentStatus, id)
	return err
}

const updatePrintJobStatus = `-- name: UpdatePrintJobStatus :exec
UPDATE print_queue
SET status = ?, retry_count = ?
WHERE id = ?
`

type UpdatePrintJobStatusParams struct {
	Status     string `json:"status"`
	RetryCount int64  `json:"retry_count"`
	ID         string `json:"id"`
}

func (q *Queries) UpdatePrintJobStatus(ctx context.Context, arg UpdatePrintJobStatusParams) error {
	_, err := q.db.ExecContext(ctx, updatePrintJobStatus, arg.Status, arg.RetryCount, arg.ID)
	return err
}
